# ⼀、HTML、HTTP、web综合问题

#### 1.Doctype的作用？标准模式和兼容模式各有什么区别？

+ 声明位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现
+ 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作

#### 2 **<img>** 的 **title** 和 **alt** 有什么区别

+ 通常当⿏标滑动到元素上的时候显示

+ alt 是 <img> 的特有属性，是图⽚内容的等价描述，⽤于图⽚⽆法加载时显示、读屏器 

  阅读图⽚。可提图⽚⾼可访问性，除了纯装饰图⽚外都必须设置有意义的值，搜索引擎会 

  重点分析。 

#### 3 语义化的理解

+ ⽤正确的标签做正确的事情！

+ HTML 语义化就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析；

+ 在没有样式 CSS 情况下也以⼀种⽂档格式显示，并且是容易阅读的。

+ 搜索引擎的爬⾍依赖于标记来确定上下⽂和各个关键字的权重，利于 SEO 。

+ 使阅读源代码的⼈对⽹站更容易将⽹站分块，便于阅读维护理解。

#### 4 iframe有哪些优缺点？

+ iframe 会阻塞主⻚⾯的 Onload 事件
+ 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO
+ iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏ 加载
+ 使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过
javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题

#### 5 请描述⼀下 cookies ， sessionStorage 和 localStorage 的区别？
+ cookie 是⽹站为了标示⽤户身份⽽储存在⽤户本地终端（Client Side）上的数据（通常 经过加密）
+ cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回 传递
+ sessionStorage 和 localStorage 不会⾃动把数据发给服务器，仅在本地保存
+ 存储⼤⼩：
	+ cookie 数据⼤⼩不能超过4k
	+ sessionStorage 和 localStorage 虽然也有存储⼤⼩的限制，但⽐ cookie ⼤得 多，可以达到5M或更⼤
+ 有期时间：
	+ localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据
	+ sessionStorage 数据在当前浏览器窗⼝关闭后⾃动删除
	+ cookie 设置的 cookie 过期时间之前⼀直有效，即使窗⼝或浏览器关闭

#### 6 HTML5有哪些新特性
+ HTML5 现在已经不是 SGML 的⼦集，主要是关于图像，位置，存储，多任务等功能的增 加
	+ 绘画 canvas
	+ ⽤于媒介回放的 video 和 audio 元素
	+ 本地离线存储 localStorage ⻓期存储数据，浏览器关闭后数据不丢失
	+ sessionStorage 的数据在浏览器关闭后⾃动删除
	+ 语意化更好的内容元素，⽐如 article 、 footer 、 header 、 nav 、 section
	+ 表单控件， calendar 、 date 、 time 、 email 、 url 、 search
	+ 新的技术 webworker 、 websocket 、 Geolocation

#### 7 HTTP状态码及其含义
+ 1XX ：信息状态码
	+ 100 Continue 继续，⼀般在发送 post 请求时，已发送了 http header 之后服务端 将返回此信息，表示确认，之后发送具体参数信息
+ 2XX ：成功状态码
	+ 200 OK 正常返回信息
	+ 201 Created 请求成功并且服务器创建了新的资源
	+ 202 Accepted 服务器已接受请求，但尚未处理
+ 3XX ：重定向
	+ 301 Moved Permanently 请求的⽹⻚已永久移动到新位置。
	+ 302 Found 临时性重定向。
	+ 303 See Other 临时性重定向，且总是使⽤ GET 请求新的 URI 。
	+ 304 Not Modified ⾃从上次请求后，请求的⽹⻚未修改过。
+ 4XX ：客户端错误
	+ 400 Bad Request 服务器⽆法理解请求的格式，客户端不应当尝试再次使⽤相同的内 容发起请求。
	+ 401 Unauthorized 请求未授权。
	+ 403 Forbidden 禁⽌访问。
	+ 404 Not Found 找不到如何与 URI 相匹配的资源。
+ 5XX: 服务器错误
	+ 500 Internal Server Error 最常⻅的服务器端错误。
	+ 503 Service Unavailable 服务器端暂时⽆法处理请求（可能是过载或维护）。

#### 8 get / post的区别
+ get: 缓存、请求长度受限、会被历史保存记录
	+ 无副作用(不修改资源)，幂等(请求次数与资源无关)的场景
+ post: 安全、大数据、更多编码类型
+ 冪等/不冪等（可缓存/不可缓存）
	+ get请求是冪等的，所以get请求的数据是可以缓存的
	+ 而post请求是不冪等的，查询查询对数据是有副作用的，是不可缓存的
+ 传参
	+ get传参，参数是在url中的
		+ 准确的说get传参也可以放到body中，只不过不推荐使用
	+ post传参，参数是在请求体中
		+ 准确的说post传参也可以放到url中，只不过不推荐使用
+ 安全性
	+ get较不安全
	+ post较为安全
	+ 准确的说两者都不安全，都是明文传输的，在路过公网的时候都会被访问到，不管是url还是header还是body，都会被访问到，要想做到安全，就需要使用https
+ 参数长度
	+ get参数长度有限，是较小的
		+ 准确来说，get在url传参的时候是很小的
	+ post传参长度不受限制
+ 发送数据
	+ post传参发送两个请求包，一个是请求头，一个是请求体，请求头发送后服务器进行验证，要是验证通过的话就会给客户端发送一个100-continue的状态码，然后就会发送请求体
+ 字符编码
	+ get在url上传输的时候只允许ASCII编码

#### 9 如何进⾏⽹站性能优化
+ content ⽅⾯
	+ 减少 HTTP 请求：合并⽂件、 CSS 精灵、 inline Image
	+ 减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名
	+ 减少 DOM 元素数量
+ Server ⽅⾯
	+ 使⽤ CDN
	+ 配置 ETag
	+ 对组件使⽤ Gzip 压缩
+ Cookie ⽅⾯
	+ 减⼩ cookie ⼤⼩
+ css ⽅⾯
	+ 将样式表放到⻚⾯顶部
	+ 不使⽤ CSS 表达式
	+ 使⽤ <link> 不使⽤ @import
+ Javascript ⽅⾯
	+ 将脚本放到⻚⾯底部
	+ 将 javascript 和 css 从外部引⼊
	+ 压缩 javascript 和 css
	+ 删除不需要的脚本
	+ 减少 DOM 访问
+ 图⽚⽅⾯
	+ 优化图⽚：根据实际颜⾊需要选择⾊深、压缩
	+ 优化 css 精灵
	+ 不要在 HTML 中拉伸图⽚

#### 10 从浏览器地址栏输⼊url到显示⻚⾯的步骤
+ DNS 解析
+ TCP 三次握手
+ 发送请求，分析 url，设置请求报文(头，主体)
+ 服务器返回请求的文件 (html)
+ 浏览器渲染
	+ HTML parser --> DOM Tree
		+ 标记化算法，进行元素状态的标记
		+ dom 树构建
	+ CSS parser --> Style Tree
		+ 解析 css 代码，生成样式树
	+ attachment --> Render Tree
		+ 结合 dom树 与 style树，生成渲染树
	+ layout: 布局
	+ GPU painting: 像素绘制页面

#### 11 TCP三次握手
+ 建立连接前，客户端和服务端需要通过握手来确认对方:
	+ 客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认
	+ 服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态
	+ 客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态

#### 12 TCP四次挥手
+ 客户端 -- FIN --> 服务端， FIN—WAIT
+ 服务端 -- ACK --> 客户端， CLOSE-WAIT
+ 服务端 -- ACK,FIN --> 客户端， LAST-ACK
+ 客户端 -- ACK --> 服务端，CLOSED

#### 13 浏览器下事件循环(Event Loop)
+ 事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表
	+ 微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
	+ 宏任务 macrotask(task): setTimout / script / IO / UI Rendering
	+ 注意：Promise是同步任务

#### 14 重绘与回流
当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。
+ 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少
+ 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
	+ 页面初次渲染
	+ 浏览器窗口大小改变
	+ 元素尺寸、位置、内容发生改变
	+ 元素字体大小变化
	+ 添加或者删除可见的 dom 元素
	+ 激活 CSS 伪类（例如：:hover）
	+ 查询某些属性或调用某些方法
		+ clientWidth、clientHeight、clientTop、clientLeft
		+ offsetWidth、offsetHeight、offsetTop、offsetLeft
		+ scrollWidth、scrollHeight、scrollTop、scrollLeft
		+ getComputedStyle()
		+ getBoundingClientRect()
		+ scrollTo()
回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。

#### 15 V8垃圾回收机制
垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。
+ 新生代空间: 用于存活较短的对象
	+ 又分成两个空间: from 空间 与 to 空间
	+ Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法
		+ 存活的对象从 from space 转移到 to space
		+ 清空 from space
		+ from space 与 to space 互换
		+ 完成一次新生代GC
+ 老生代空间: 用于存活时间较长的对象
	+ 从 新生代空间 转移到 老生代空间 的条件
		+ 经历过一次以上 Scavenge GC 的对象
		+ 当 to space 体积超过25%
	+ 标记清除算法: 标记存活的对象，未被标记的则被释放
		+ 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能
		+ 并发标记(最新技术): 不阻塞 js 执行
	+ 压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化

#### 16 内存泄露
+ 意外的全局变量: 无法被回收
+ 定时器: 未被正确关闭，导致所引用的外部变量无法被释放
+ 事件监听: 没有正确销毁 (低版本浏览器可能出现)
+ 闭包: 会导致父级中的变量无法被释放
+ dom 引用: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

#### 17 http/https 协议
+ 1.0 协议缺陷:
	+ 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
	+ head of line blocking: 线头阻塞，导致请求之间互相影响
+ 1.1 改进:
	+ 长连接(默认 keep-alive)，复用
	+ host 字段指定对应的虚拟站点
	+ 新增功能:
		+ 断点续传
		+ 身份认证
		+ 状态管理
		+ cache 缓存
			+ Cache-Control
			+ Expires
			+ Last-Modified
			+ Etag
+ 2.0:
	+ 多路复用
	+ 二进制分帧层: 应用层和传输层之间
	+ 首部压缩
	+ 服务端推送
+ https: 较为安全的网络传输协议
	+ 证书(公钥)
	+ SSL 加密
	+ 端口 443
+ TCP:
	+ 三次握手
	+ 四次挥手
	+ 滑动窗口: 流量控制
	+ 拥塞处理
		+ 慢开始
		+ 拥塞避免
		+ 快速重传
		+ 快速恢复
+ 缓存策略: 可分为 强缓存 和 协商缓存
	+ Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires
	+ 当缓存已经过期时，使用协商缓存
		+ 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
		+ 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)
			+ 如果一致，则直接返回 304 通知浏览器使用缓存
			+ 如不一致，则服务端返回新的资源
	+ Last-Modified 缺点：
		+ 周期性修改，但内容未变时，会导致缓存失效
		+ 最小粒度只到 s， s 以内的改动无法检测到
	+ Etag 的优先级高于 Last-Modified

#### 18 跨域
+ JSONP: 利用<script>标签不受跨域限制的特点，缺点是只能支持 get 请求
```javascript
function jsonp(url, jsonpCallback, success) {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}
```

+ 设置 CORS: Access-Control-Allow-Origin
+ postMessage

#### 19、宏任务和微任务都是怎样执行的
+ 执行宏任务script
+ 进入script后，所有的同步任务主线程执行
+ 所有宏任务放入宏任务执行队列
+ 所有微任务放入微任务执行队列
+ 先清空微任务队列
+ 再取一个宏任务，执行，再清空微任务队列
+ 依次循环

#### 20、什么是requestAnimationFrame？
+ requestAnimationFrame请求数据帧可以用做动画执行
+ 可以自己决定什么时机调用该回调函数
+ 能保证每次频幕刷新的时候只被执行一次
+ 页面被隐藏或者最小化的时候暂停执行，返回窗口继续执行，有效节省CPU
```js
    var s = 0
    function f() {
      s++
      console.log(s);
      if (s < 999) {
        window.requestAnimationFrame(f)
      }
    }
    window.requestAnimationFrame(f)
```

#### 21、webpack常用的几个对象及解释
+ entry 入口文件
+ output 输出文件
	+ 一般配合node的path模块使用
```js
    // 入口文件
    entry:"./src/index.js",
    output:{
        // 输出文件名称
        filename:"bundle.js",
        // 输出的路径（绝对路径）
        path:path.resolve(__dirname,"dist") //利用node模块的path 绝对路径
    },
    // 设置模式
    mode:"development"
```
+ mode 设计模式
+ module（loader）
	+ 里面有一个rules数组对某种格式的文件进行转换处理（转换规则）
	+ use数组解析顺序是从下到上逆序执行的
	```js
	module:{
	       // 对某种格式的文件进行转换处理（转换规则）
	       rules:[
	           {
	               // 用到正则表达式
	               test:/\.css$/,      //后缀名为css格式的文件
	               use:[
	                   // use数组解析顺序是从下到上逆序执行的
	                   // 先用css-loader 再用style-loader
	                   // 将js的样式内容插入到style标签里
	                   "style-loader",
	                   // 将css文件转换为js
	                   "css-loader"
	               ]
	           }
	       ]
	   }
	 
	// -----------------------------------------------------vue的
	module.exports={
	    module:{
	        rules:[
	            {
	                test: /\.vue$/,
	                use:["vue-loader"]
	            }
	        ]
	    }
	}	
	```
	
+ plugin
	+ 插件配置
	```js
	const uglifyJsPlugin = reqiure('uglifyjs-webpack-plugin')
	
	module.exports={
		plugin:[
			new uglifyJsPlugin()	//丑化
		]
	}
	
	```
+ devServer
	+ 热更新
	```js
	    devServer:{
	        // 项目构建路径
	        contentBase:path.resolve(__dirname,"dist"),
	        // 启动gzip亚索
	        compress:true,
	        // 设置端口号
	        port:2020,
	        // 自动打开浏览器:否
	        open:false,
	        //页面实时刷新(实时监听)
	        inline:true
	    }
	
	```
+ resolve
	+ 配置路径规则
	+ alias 别名
	```js
	module.exports= {
		resolve:{
			//如果导入的时候不想写后缀名可以在resolve中定义extensions
			extensions:['.js','.css','.vue']
			//alias:别名
			alias:{
				//导入以vue结尾的文件时，会去寻找vue.esm.js文件
				'vue$':"vue/dist/vue.esm.js"
			}
		}
	}
	
	```
+ babel（ES6转ES5）
	
	+ 下载插件babel-loader,在module（loader）中配置

#### 22、webpack打包原理？
> 本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。
webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。
webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。


#### 23、前后端分离（面试：说一说你理解的前后端分离？）
`从某个具体的技术切入来回答对前后端分离的理解本身就是一种局限的看法，这只会显示出自己对该问题理解的浅显。`
> 究其本质原因：前端开发没有像后端开发那样实现工程化、模块化、可复用化的思想。所以就会出现前后端开发不协调、效率低、扯皮的问题，这很不利于项目开发。因此项目管理者就想办法来解决这种问题，如何解决？→解耦。在软件领域，任何复杂的问题面前，高内聚、低耦合这种原则几乎总是能见效。所以前后端分离开发出现了，把前端开发的责任从后端开发人员身上拿掉，给前端开发工程师一个单独的岗位和责任领域，将前端也工程化、模块化、项目化。这才是前后端分离开发最开始的来源。这些与vue、react框架没有什么关系，它们充其量只是一种具体实现方式而已。从本质上来看，前后端分离并不是一个技术问题，而是一个工程化考量和项目管理的问题。

**前后端分离核心思想是前端HTML页面通过AJAX调用后端的RESTFUL API接口并使用JSON数据进行交互。**

#### 24、setInterval()和setTimeout()区别
`尽量不用setInterval()`
**原因一、setInterval()无视代码错误**
> setInterval有个讨厌的习惯，即对自己调用的代码是否报错这件事漠不关心。换句话说，如果setInterval执行的代码由于某种原因出了错，它还会持续不断（不管不顾）地调用该代码。

**原因二、setInterval无视网络延迟**
> 假设你每隔一段时间就通过Ajax轮询一次服务器，看看有没有新数据（注意：如果你真的这么做了，那恐怕你做错了；建议使用“补偿性轮询”（backoff polling））。而由于某些原因（服务器过载、临时断网、流量剧增、用户带宽受限，等等），你的请求要花的时间远比你想象的要长。但setInterval不在乎。它仍然会按定时持续不断地触发请求，最终你的客户端网络队列会塞满Ajax调用。

**原因三、setInterval不保证执行**
> 与setTimeout不同，你并不能保证到了时间间隔，代码就准能执行。如果你调用的函数需要花很长时间才能完成，那某些调用会被直接忽略。

#### 25、浏览器内核
> IE	Trident
> firefox	Gecko
> Safari	webkit
> chrome	Blink
> Opera		blink

#### 26、请说明px,em,rem,vw,vh,rpx等单位的特性
+ px
	+ 像素
+ em
	+ 当前元素的字体大小
+ rem
	+ 根元素字体大小
+ vw
	+ 100vw是总宽度
+ vh
	+ 100vh是总高度
+ rpx
	+ 750rpx是总宽度


# ⼆、CSS部分

#### 1 css sprite是什么,有什么优缺点
+ 概念：将多个⼩图⽚拼接到⼀个图⽚中。通过 background-position 和元素尺⼨调节需 要显示的背景图案。
+ 优点：
	+ 减少 HTTP 请求数，极⼤地提⾼⻚⾯加载速度
	+ 增加图⽚信息重复度，提⾼压缩⽐，减少图⽚⼤⼩
	+ 更换⻛格⽅便，只需在⼀张或⼏张图⽚上修改颜⾊或样式即可实现
+ 缺点：
	+ 图⽚合并麻烦
	+ 维护麻烦，修改⼀个图⽚可能需要从新布局整个图⽚，样式

#### 2 display: none; 与 visibility: hidden; 的区别
+ 联系：它们都能让元素不可⻅
+ 区别：
	+ display:none ;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；
visibility: hidden ;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内 容不可⻅
	+ display: none ;是⾮继承属性，⼦孙节点消失由于元素从渲染树消失造成，通过修改
⼦孙节点属性⽆法显示 ；visibility: hidden; 是继承属性，⼦孙节点消失由于继承 了 hidden ，通过设置 visibility: visible; 可以让⼦孙节点显式
	+ 修改常规流中元素的 display 通常会造成⽂档重排。修改 visibility 属性只会造成 本元素的重绘。
	+ 读屏器不会读取 display: none ;元素内容；会读取 visibility: hidden; 元素内容

#### 3 link 与 @import 的区别
1. link 是 HTML ⽅式， @import 是CSS⽅式
2. link 最⼤限度⽀持并⾏下载， @import 过多嵌套导致串⾏下载，出现 FOUC (⽂档样式 短暂失效) 
3. link 可以通过 rel="alternate stylesheet" 指定候选样式
4. 浏览器对 link ⽀持早于 @import ，可以使⽤ @import 对⽼浏览器隐藏样式
5. @import 必须在样式规则之前，可以在css⽂件中引⽤其他⽂件
6. 总体来说： link 优于 @import

#### 4 盒模型
页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为：
+ content-box (W3C 标准盒模型)
+ border-box (IE 盒模型)
+ padding-box (FireFox 曾经支持)
+ margin-box (浏览器未实现)

`Tips: 理论上是有上面 4 种盒子，但现在 w3c 与 mdn 规范中均只支持 content-box 与 border-box`

#### 5 BFC
块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

`IE下为 Layout，可通过 zoom:1 触发`
+ 触发条件:
	+ 根元素
	+ position: absolute/fixed
	+ display: inline-block / table
	+ float 元素
	+ ovevflow !== visible
+ 规则:
	+ 属于同一个 BFC 的两个相邻 Box 垂直排列
	+ 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠
	+ BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)
	+ BFC 的区域不会与 float 的元素区域重叠
	+ 计算 BFC 的高度时，浮动子元素也参与计算
	+ 文字层不会被浮动层覆盖，环绕于周围
+ 应用:
	+ 阻止margin重叠
	+ 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)
	+ 自适应两栏布局
	+ 可以阻止元素被浮动元素覆盖

#### 6 居中布局
水平居中
+ 行内元素: text-align: center
+ 块级元素: margin: 0 auto
+ absolute + transform
+ flex + justify-content: center

垂直居中
+ line-height: height
+ absolute + transform
+ flex + align-items: center
+ table

水平垂直居中
+ html
```html
<body>
	<div class="div1">
		<div class="box  size">垂直水平居中</div>
	</div>
</body>
```
+ 公共css代码如下
```css
<style type="text/css">
	/* 公共样式 */
	.div1{
		width: 300px;
		height: 300px;
		border:1px solid aqua;
	}
	.box{
		background: #00FFFF;
	}
	.box.size{
		width:100px;
		height:100px;
	}
</style>
```
+ 1、absolute 和 margin auto（常用）
```css
.div1{
	position: relative;
	}
	.box{
		position: absolute;
		top:0;
		left: 0;
		right: 0;
		bottom: 0;
		margin: auto;
	}
```
+ 2、absolute 和margin（负值）
```css
.div1{
	position: relative;
	}
.box{
	top: 50%;
	left: 50%;
	position: absolute;
	margin-top: -50px;
	margin-left: -50px;
} 
```
+ 3、flex（常用）
```css
.div1{
	display: flex;
	justify-content: center;
	align-items: center;
}
```
+ 4、lineheight
利用行内元素居中属性也可以做到水平垂直居中。把box设置为行内元素，通过text-align就可以实现水平居中vertical-align 也可以在垂直方向做到居中（PS：这种方法需要在子元素中将文字显示重置为想要的效果）
```css
.div1{
	line-height: 300px;
	text-align: center;
	font-size: 0px;
}
.box{
	font-size: 10px;
	display: inline-block;
	vertical-align: middle;
	line-height:initial;
	/* 修正文字 */
 	text-align: left;
}
```
+ 5、absolute 和 transform
```css
.div1{
	position: relative;
}
.box{
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%,-50%);
}
```
+ 6、css-table
```css
.div1{
	display:table-cell;
	text-align: center;
	vertical-align: middle;
}
.box{
	display:inline-block;
}
```

#### 7 选择器优先级
+ !important > 行内样式 > #id > .class > tag > * > 继承 > 默认
+ 选择器 从右往左 解析

#### 8. CSS预处理器(Sass/Less/Postcss)

CSS预处理器的原理: 是将类 CSS 语言通过 Webpack 编译 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:
+ 嵌套
+ 变量
+ 循环语句
+ 条件语句
+ 自动前缀
+ 单位转换
+ mixin复用

#### 9清除浮动的⼏种⽅式，各⾃的优缺点
1.父级div定义 height
+ 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。
+ 优点：简单、代码少、容易掌握
+ 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题

2，结尾处加空div标签 clear:both
+ 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度
+ 优点：简单、代码少、浏览器支持好、不容易出现怪问题
+ 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好

3，父级div定义 伪类:after 和 zoom
+ 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题
+ 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）
+ 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持
```css
.clearfix:after{
  display:table;
  clear:both;
  content:"";
  height:0px;
}
.clearfix {*zoom:1;} /*照顾IE6，IE7就可以了*/
```

4，父级div定义 overflow:hidden（利用BFC检测区域的浮动的盒子高度）
+ 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden生成BFC时，浏览器会自动检查浮动区域的高度
+ 优点：简单、代码少、浏览器支持好
+ 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。

#### 10 display有哪些值？说明他们的作⽤
+ block 转换成块状元素。
+ inline 转换成⾏内元素。
+ none 设置元素不可⻅。
+ inline-block 象⾏内元素⼀样显示，但其内容象块类型元素⼀样显示。
+ list-item 象块类型元素⼀样显示，并添加样式列表标记。
+ table 此元素会作为块级表格来显示
+ inherit 规定应该从⽗元素继承 display 属性的值

#### 11 display:inline-block 什么时候不会显示间隙？
+ 移除空格
+ 使⽤ margin 负值
+ 使⽤ font-size:0
+ letter-spacing
+ word-spacing

#### 12 如何实现⼩于12px的字体效果
+ 1、移动端
```css
.font{
   // 10px / 12px = 0.83
   ransform: scale(0.83);
}
```
+ 2、PC端
避免不支持 CSS3 浏览器的情况，我们也可以通过降级处理，将字体变回12px；最后兼容 IE：*font-size:10px;
```css
.font{
   font-size: 12px;
   transform: scale(0.83,0.83) ;
   *font-size: 10px;
}
```

#### 13 为什么要初始化CSS样式?
+ 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化
往往会出现浏览器之间的⻚⾯显示差异。
当然，初始化样式会对 SEO 有⼀定的影响，但⻥和熊掌不可兼得，但⼒求影响最⼩的情况 下初始化

#### 14 CSS合并⽅法
+ 避免使⽤ @import 引⼊多个 css ⽂件，可以使⽤ CSS ⼯具将 CSS 合并为⼀个 CSS ⽂ 件，例如使⽤ Sass\Compass 等

#### 15 postcss的作⽤
+ 可以直观的理解为：它就是⼀个平台。为什么说它是⼀个平台呢？因为我们直接⽤它，感 觉不能⼲什么事情，但是如果让⼀些插件在它上⾯跑，那么将会很强⼤
+ PostCSS 提供了⼀个解析器，它能够将 CSS 解析成抽象语法树
+ 通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的 CSS ，⽐如热⻔ 的： autoprefixer
+ postcss 可以对sass处理过后的 css 再处理 最常⻅的就是 autoprefixer

#### 16 知道css有个content属性吗？有什么作⽤？有什么应⽤？
`css的 content 属性专⻔应⽤在 before/after 伪元素上，⽤于来插⼊⽣成 内容。最常⻅的应⽤是利⽤伪类清除浮动。`

```css
/**⼀种常⻅利⽤伪类清除浮动的代码**/
.clearfix:after {
 	content:"."; //这⾥利⽤到了content属性
 	display:block;
 	height:0;
 	visibility:hidden;
 	clear:both; 
}
.clearfix {
 	*zoom:1; 
}
```

#### 17、伪元素和伪类的区别
其中伪类和伪元素的根本区别在于：**它们是否创造了新的元素。**
> 伪元素/伪对象：不存在在DOM文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。

![image-20210307115903833](C:\Users\LI\AppData\Roaming\Typora\typora-user-images\image-20210307115903833.png)


#### 18、用css画出一个三角形并说出它是什么原理
```css
.example{
	width: 0;
	height: 0;
    border-top:1px solid blue;
    border-right:1px solid transparent;
    border-bottom:1px solid transparent;
    border-left:1px solid transparent;
}
```
> 其实css实现三角的原理就是利用了边框是梯形的这一属性。而且基本上还是等腰梯形。接下来，我们把梯形的上边改为0，就得到了四个三角形


#### 19、谈谈对grid的理解
**html代码：**
```html
<div class="container">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
</div>
```
**css代码**
```css
* {
   	margin: 0;
    padding: 0;
}
// grid布局的关键代码！！！
// grid布局的关键代码！！！
// grid布局的关键代码！！！
.container {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 50px 50px;
}
.container div {
    text-align: center;
    line-height: 50px;
    border: 2px solid;
    margin: 2px;
}
.container div:nth-child(1) {background: yellow;}
.container div:nth-child(2) {background: orange;}
.container div:nth-child(3) {background: red;}
.container div:nth-child(4) {background: yellowgreen;}
.container div:nth-child(5) {background: paleturquoise;}
.container div:nth-child(6) {background: greenyellow;}
```

#### 20、谈谈对flex的理解
**采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。**

![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)

> 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。
项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

#### 21、css文字溢出隐藏显示三个点
**单行文本溢出隐藏**
```css
white-space: nowrap;
text-overflow: ellipsis;
overflow: hidden;
```
**多行文本溢出隐藏**
```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 3;
-webkit-box-orient: vertical;
```



# 三、JavaScript

#### 1 闭包
+ 闭包就是能够读取其他函数内部变量的函数
+ 闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个
函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤ 链域
+ 闭包的特性：
	+ 函数内再嵌套函数
	+ 内部函数可以引⽤外层的参数和变量
	+ 参数和变量不会被垃圾回收机制回收

**说说你对闭包的理解**

+ 使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺 点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在js中，函数即 闭包，只有函数才会产⽣作⽤域的概念
+ 闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保 持在内存中
+ 闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法
+ 好处：能够实现封装和缓存等；
+ 坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题

**使⽤闭包的注意点**

+ 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否 则会造成⽹⻚的性能问题，在IE中可能导致内存泄露
+ 解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除

**闭包会产生一个很经典的问题:**
`多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。`
+ 解决:
	+ 变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找
	+ 使用setTimeout包裹，通过第三个参数传入
	+ 使用 块级作用域，让变量成为自己上下文的属性，避免共享

#### 2、原型 / 构造函数 / 实例
+ 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__ (非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。
+ 构造函数: 可以通过new来 新建一个对象 的函数。
+ 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。

```javascript
// 实例
const instance = new Object()
```
则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:

```javascript
// 原型
const prototype = Object.prototype
```
这里我们可以来看出三者的关系:

```javascript
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的
//      instance.hasOwnProperty('constructor') === false   
实例.constructor === 构造函数
```


![img](https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 3、null，undefined 的区别
+ undefined 表示不存在这个值。
+ undefined :是⼀个表示"⽆"的原始值或者说表示"缺少值"，就是此处应该有⼀个值，但 是还没有定义。当尝试读取时会返回 undefined
+ 例如变量被声明了，但没有赋值时，就等于 undefined
+ null 表示⼀个对象被定义了，值为“空值”
+ null : 是⼀个对象(空对象, 没有任何属性和⽅法)
+ 例如作为函数的参数，表示该函数的参数不是对象；
+ 在验证 null 时，⼀定要使⽤ === ，因为 == ⽆法分别 null 和 undefined

#### 4 ⾯向对象编程思想
+ 基本思想是使⽤对象，类，继承，封装等基本概念来进⾏程序设计
+ 优点
	+ 易维护
		+ 采⽤⾯向对象思想设计的结构，可读性⾼，由于继承的存在，即使改变需求，那么维 护也只是在局部模块，所以维护起来是⾮常⽅便和较低成本的
		+ 易扩展
		+ 开发⼯作的重⽤性、继承性⾼，降低重复⼯作量。
		+ 缩短了开发周期

#### 5 原型链
**原型链是由原型对象组成，每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型，__proto__ 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。**
+ 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出 undefined；
+ 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。
**JavaScript对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。**

![img](https://user-gold-cdn.xitu.io/2019/10/20/16de955ca89f6091?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

+ 对象的 hasOwnProperty() 来检查对象自身中是否含有该属性
+ 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true

#### 6、执行上下文(EC)
执行上下文可以简单理解为一个对象:
+ 它包含三个部分:
	+ 变量对象(VO)
	+ 作用域链(词法作用域)
	+ this指向
+ 它的类型:
	+ 全局执行上下文
	+ 函数执行上下文
	+ eval执行上下文
+ 代码执行过程:
	+ 创建 全局上下文 (global EC)
	+ 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层
	+ 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起
	+ 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行

#### 7、0.1+0.2为什么不等于0.3？
`0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。`

#### 8、js数据检测
**1. typeof 是否能正确判断类型？**
+ 对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。
+ 但对于引用数据类型，除了函数之外，都会显示"object"。
+ 因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true

**2. instanceof能否判断基本数据类型？**
+ 能。比如下面这种方式:
```js
class PrimitiveNumber {
  static [Symbol.hasInstance](x) {
    return typeof x === 'number'
  }
}
console.log(111 instanceof PrimitiveNumber) // true
```
+ 其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。

**3. 能不能手动实现一下instanceof的功能？**

+ 核心: 原型链的向上查找
```javascript
function myInstanceof(left, right) {
    //基本数据类型直接返回false
    if(typeof left !== 'object' || left === null) return false;
    //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {
        //查找到尽头，还没找到
        if(proto == null) return false;
        //找到相同的原型对象
        if(proto == right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
}
```

测试：

```javascript
console.log(myInstanceof("111", String)); //false
console.log(myInstanceof(new String("111"), String));//true
```
**4、constructor ： 基于构造函数检测数据类型（也是基于类的方式)**
+ 原理：在类的原型上一般都会带有constructor属性，存储当前类本身，我们也是利用这一点，获取某的实例
constructor属性值，验证是否为所属的类，从而进行数据类型检测
+ 局限性：constructor属性值容易被修改

**5、Object.prototype.toString.call() ：检测数据类型最好的办法**
`Object.prototype.toString.call([value])：调用Object原型上的toString方法，让方法执行的时候，方法中的this是要检测的数据类型 ，从而获取到数据类型所属类的详细信息`
+ 信息的模板:
	+ "[object 所属类]" ，例如："[object Array]"
在所有的数据类型类中,它们的原型上都有toString方法,除Object.prototype.toString不是把数据值转换为字符串，其余的都是转为字符串，而Object原型上的toString是检测当前实例隶属类的详细信息的（检测数据类型）

obj.toString()
    1.首先基于原型链查找机制，找到Object.prototype.toString
    2.把找到的方法执行，方法中的this -> obj
    3.方法内部把this（obj）的所属类信息输出
    =>方法执行，方法中的this是谁，就是检测谁的所属类信息
    
```js
//这个方法很强大，所有数据类型隶属的类信息检测的一清二楚
"[object Number]"  String/Boolean/Null/Undefined/Symbol/Object/Array/RegExp/Date/Math/Function...
```



#### 9、Content-Type

**application/x-www-form-urlencoded**
> HTTP会将请求参数用key1=val1&key2=val2的方式进行组织，并放到请求实体里面，注意如果是中文或特殊字符如"/"、","、“:" 等会自动进行URL转码。不支持文件，一般用于表单提交。

**multipart/form-data**
> 与application/x-www-form-urlencoded不同，这是一个多部分多媒体类型。首先生成了一个 boundary 用于分割不同的字段，在请求实体里每个参数以------boundary开始，然后是附加信息和参数名，然后是空行，最后是参数内容。多个参数将会有多个boundary块。如果参数是文件会有特别的文件域。最后以------boundary–为结束标识。multipart/form-data支持文件上传的格式，一般需要上传文件的表单则用该类型。

**application/json**
> JSON 是一种轻量级的数据格式，以“键-值”对的方式组织的数据。这个使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到请求实体里，不进行任何处理。服务端/客户端会按json格式解析数据（约定好的情况下）。



#### 10、作用域
**执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域**

特性:
+ 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量
+ 非匿名自执行函数，函数变量为 只读 状态，无法修改
```javascript
let foo = function() { console.log(1) };
(function foo() {
    foo = 10  // 由于foo在函数中只为可读，因此赋值无效
    console.log(foo)
}()) 

// 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }
```

#### 11、作用域链

我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。
+ 由两部分组成:
	+ [[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO
	+ AO: 自身活动对象

如此 [[scopr]]包含[[scope]]，便自上而下形成一条 链式作用域。

#### 12、请解释什么是事件代理
+ 事件代理（ Event Delegation ），⼜称之为事件委托。是 JavaScript 中常⽤绑定事 件的常⽤技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给⽗元素，让⽗元 素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使⽤事件代理的好处是 可以提⾼性能
+ 可以⼤量节省内存占⽤，减少事件注册，⽐如在 table 上代理所有 td 的 click 事件就 ⾮常棒

#### 13、事件模型
`W3C 中定义事件的发⽣经历三个阶段：捕获阶段（ capturing ）、⽬标阶段 （ targetin ）、冒泡阶段（ bubbling ）`

+ 冒泡型事件：当你使⽤事件冒泡时，⼦级元素先触发，⽗级元素后触发
+ 捕获型事件：当你使⽤事件捕获时，⽗级元素先触发，⼦级元素后触发
+ DOM 事件流：同时⽀持两种事件模型：捕获型事件和冒泡型事件
+ 阻⽌冒泡：在 W3c 中，使⽤ stopPropagation() ⽅法；在IE下设置 cancelBubble =
true
+ 阻⽌捕获：阻⽌事件的默认⾏为，例如 click - <a> 后的跳转。在 W3c 中，使⽤
preventDefault() ⽅法，在 IE 下设置 window.event.returnValue = false

#### 14、new操作符在执行的时候⼲了什么呢?
**1.创建一个空对象**
```javascript
let obj = new Object();
```

**2.链接到原型**
把 obj 的proto 指向构造函数Func的原型对象 prototype，此时便建立了 obj 对象的原型链：
obj->Func.prototype->Object.prototype->null
代码为：
```javascript
obj.__proto__ = Func.prototype;
```
**3.绑定this值（让Func中的this指向obj，并执行Func的函数体。）**
```javascript
let result = Func.call(obj);
```
**4.返回新对象**

判断Func的返回值类型：如果无返回值 或者 返回一个非对象值，则将 obj 作为新对象返回；否则会将 result 作为新对象返回。
```javascript
if (typeof(result) == "object"){
  func=result;
}
else{
    func=obj;
}
```

#### 15、对象的拷贝
**浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响**
+ Object.assign
+ 展开运算符(...)

**深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响**

+ 1. 简易版及问题
```javascript
JSON.parse(JSON.stringify());
```

估计这个api能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：
`1、无法解决循环引用的问题。举个例子：`
```javascript
const a = {val:2};
a.target = a;
```
拷贝a会出现系统栈溢出，因为出现了无限递归的情况。
`2、无法拷贝一写特殊的对象，诸如 RegExp, Date, Set, Map等。`
`3、无法拷贝函数(划重点)。`
因此这个api先pass掉，我们重新写一个深拷贝，简易版如下:
```javascript
const deepClone = (target) => {
  if (typeof target === 'object' && target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = deepClone(target[prop]);
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```
```javascript
//⽅法⼆：
 /**
 * 克隆⼀个对象
 * @param Obj
 * @returns
 */
 function clone(Obj) { 
 	var buf; 
 	if (Obj instanceof Array) { 
 		buf = []; //创建⼀个空的数组
 		var i = Obj.length; 
 		while (i--) { 
 			buf[i] = clone(Obj[i]); 
 		} 
 		return buf; 
 	}else if (Obj instanceof Object){ 
 		buf = {}; //创建⼀个空对象
 		for (var k in Obj) { //为这个对象添加新的属性
 			buf[k] = clone(Obj[k]); 
 		} 
 		return buf; 
 	}else{ //普通变量直接赋值
 		return Obj; 
 	} 
 }

//3.使用循环加递归
function deepClone(origin,target){
    var target = target ||{},
    	toStr = Object.prototype.toString,
        arrType = '[object Array]';
    for(var key in origin){
        if(origin.hasOwnProperty(key)){
            if(typeof(origin[key]) === 'object' && origin[key] !== null){
                toStr.call(origin[key]) === arrType ? target[key] = [] :target[key] = {}
                deepClone(origin[key],target[key])
            }else {
                target[key] = origin[key]
            }
        }
    }
    return target
}
console.log(obj,obj1)
```


#### 16、 谈谈变量提升
**当执⾏ JS 代码时，会⽣成执⾏环境，只要代码不是写在函数中的，就是在全 局执⾏环境中，函数中的代码会产⽣函数执⾏环境，只此两种执⾏环境**
⽼⽣常谈的例⼦:

```javascript
var b() // call b
console.log(a) // undefined
var a = 'Hello world'
function b() {
 console.log('call b') }
```
`这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部， 这其实没有什么错误，便于⼤家理解。但是更准确的解释应该是：在⽣成执⾏环境 时，会有两个阶段。第⼀个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函 数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量 只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可 以直接提前使⽤`

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升
```js
b() // call b second
function b() {
 console.log('call b fist') }
function b() {
 console.log('call b second') }
var b = 'Hello world'
```
`复制代码 var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。 let 不能在 声明前使⽤，但是这并不是常说的 let 不会提升， let 提升了，在第⼀阶 段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声 明前使⽤`

#### 17、什么是单线程，和异步的关系
+ 单线程 - 只有⼀个线程，只能做⼀件事
+ 原因 - 避免 DOM 渲染的冲突
	+ 浏览器需要渲染 DOM
	+ JS 可以修改 DOM 结构
	+ JS 执⾏的时候，浏览器 DOM 渲染会暂停
	+ 两段 JS 也不能同时执⾏（都修改 DOM 就冲突了）
	+ webworker ⽀持多线程，但是不能访问 DOM
+ 解决⽅案 - 异步

#### 18、let var const
let
+ 允许你声明⼀个作⽤域被限制在块级中的变量、语句或者表达式
+ let绑定不受变量提升的约束，这意味着let声明不会被提升到当前
+ 该变量处于从块开始到初始化处理的“暂存死区”

var
+ 声明变量的作⽤域限制在其声明位置的上下⽂中，⽽⾮声明变量总是全局的
+ 由于变量声明（以及其他声明）总是在任意代码执⾏之前处理的，所以在代码中的任意位 置声明变量总是等效于在代码开头声明

const
+ 声明创建⼀个值的只读引⽤ (即指针)
+ 基本数据当值发⽣改变时，那么其对应的指针也将发⽣改变，故造成 const 申明基本数 据类型时
+ 再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5 时 将会报错
+ 但是如果是复合类型时，如果只改变复合类型的其中某个 Value 项时， 将还是正常使⽤

#### 19、谈⼀谈箭头函数与普通函数的区别？
+ 函数体内的 this 对象，就是定义时所在的对象，⽽不是使⽤时所在的对象
+ 不可以当作构造函数，也就是说，不可以使⽤ new 命令，否则会抛出⼀个错误
+ 不可以使⽤ arguments 对象，该对象在函数体内不存在。如果要⽤，可以⽤ Rest 参数 代替
+ 不可以使⽤ yield 命令，因此箭头函数不能⽤作 Generator 函数

#### 20、谈谈你对AMD、CMD的理解
+ CommonJS 是服务器端模块的规范， Node.js 采⽤了这个规范。 CommonJS 规范加载模 块是同步的，也就是说，只有加载完成，才能执⾏后⾯的操作。 AMD 规范则是⾮同步加载 模块，允许指定回调函数
+ AMD 推荐的⻛格通过返回⼀个对象做为模块对象， CommonJS 的⻛格通过对
module.exports 或 exports 的属性赋值来达到暴露模块对象的⽬的
**es6模块 CommonJS、AMD、CMD**

+ CommonJS 的规范中，每个 JavaScript ⽂件就是⼀个独⽴的模块上下⽂（ module
context ），在这个上下⽂中默认创建的属性都是私有的。也就是说，在⼀个⽂件定义的 变量（还包括函数和类），都是私有的，对其他⽂件是不可⻅的。
+ CommonJS 是同步加载模块,在浏览器中会出现堵塞情况，所以不适⽤
+ AMD 异步，需要定义回调 define ⽅式
+ es6 ⼀个模块就是⼀个独⽴的⽂件，该⽂件内部的所有变量，外部⽆法获取。如果你希 望外部能够读取模块内部的某个变量，就必须使⽤ export 关键字输出该变量 es6 还可 以导出类、⽅法，⾃动适⽤严格模式

#### 21、offsetWidth/offsetHeight,clientWidth/clientHeight与 scrollWidth/scrollHeight的区别
+ offsetWidth/offsetHeight 返回值包含content + padding + border，效果与 e.getBoundingClientRect()相同
+ clientWidth/clientHeight 返回值只包含content + padding，如果有滚动条，也不包 含滚动条
+ scrollWidth/scrollHeight 返回值包含content + padding + 溢出内容的尺⼨

#### 22、js延迟加载的方式有哪些
+ 1、defer 属性 在<script>元素中设置 defer 属性，等于告诉浏览器立即下载，但延迟执行
+ 2、async 属性 HTML5 为 <script>标签定义了 async属性。与defer属性类似。
+ 3、JS动态创建DOM方式
+ 4、使用jQuery的getScript()方法
+ 5、让JS最后加载
+ 6、Ajax eval 用ajax下载代码，然后用eval执行

#### 23、说说严格模式的限制
+ 变量必须声明后再使用
+ 函数的参数不能有同名属性，否则报错
+ 不能使用with语句
+ 禁止this指向全局对象

#### 24、call,bind,apply的区别？
**apply，call与bind的相同点**
+ 都是函数非继承而来的方法
+ 函数有两个属性：
	+ length
	+ prototype（来继承属性与方法)
+ 函数有三个非继承而来的方法：
	+ call
	+ apply
	+ bind
+ 都可以改变函数对运行作用域，也可以说改变this对指向

**apply，call与bind的不同点**
+ 返回值不一样
	+ bind返回值类型固定：是一个绑定作用域后的函数实例
	+ apply和call的返回值类型不固定：是执行函数的返回值（啥都行，如果没有返回值则返回：undeifined）
+ 执行情况不一样
	+ bind返回一个函数之后需要调用才执行
	+ apply和call直接执行函数

**apply与call的不同点**
+ 接收的参数不一样：
	+ apply：接收一个包含多个参数的数组（oThis,[args1,…]）
	+ call：接收多个参数的列表（oThis,args1,…）

#### 25、介绍js有哪些内置对象
+ 1 Object 是 JavaScript 中所有对象的父对象
+ 2 数据封装类对象：Object、Array、Boolean、Number 和 String
+ 3 其他对象：Function、Arguments、Math、Date、RegExp、Error

#### 26、防抖与节流
**防抖与节流函数是一种最常用的 高频触发优化方式，能对性能有较大的帮助。**
+ 防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。
```javascript
function debounce(fn, wait, immediate) {
    let timer = null

    return function() {
        let args = arguments
        let context = this

        if (immediate && !timer) {
            fn.apply(context, args)
        }
        
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(context, args)
        }, wait)
    }
}
```
+ 节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。
```javascript
function throttle(fn, wait, immediate) {
    let timer = null
    let callNow = immediate
  
    return function() {
        let context = this,
            args = arguments

        if (callNow) {
            fn.apply(context, args)
            callNow = false
        }
    
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(context, args)
                timer = null
            }, wait)
        }
    }
}
```

#### 27、cookie和session的区别
+ Cookie可以存储在浏览器或者本地，Session只能存在服务器
+ session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象
+ Session比Cookie更具有安全性（Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击）
+ Session占用服务器性能，Session过多，增加服务器压力
+ 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，Session是没有大小限制和服务器的内存大小有关。

#### 28、图片懒加载的原理
```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lazyload</title>
    <style>
    img {
        display: block;
        margin-bottom: 50px;
        height: 200px;
    }
    </style>
</head>
<body>
    <img src="images/loading.gif" data-src="images/1.png">
    <img src="images/loading.gif" data-src="images/2.png">
    <img src="images/loading.gif" data-src="images/3.png">
    <img src="images/loading.gif" data-src="images/4.png">
    <img src="images/loading.gif" data-src="images/5.png">
    <img src="images/loading.gif" data-src="images/6.png">
    <img src="images/loading.gif" data-src="images/7.png">
    <img src="images/loading.gif" data-src="images/8.png">
    <img src="images/loading.gif" data-src="images/9.png">
    <img src="images/loading.gif" data-src="images/10.png">
    <img src="images/loading.gif" data-src="images/11.png">
    <img src="images/loading.gif" data-src="images/12.png">
    <script>
    function throttle(fn, delay, atleast) {//函数绑定在 scroll 事件上，当页面滚动时，避免函数被高频触发，
        var timeout = null,//进行去抖处理
        startTime = new Date();
        return function() {
           　　var curTime = new Date();
        　　　　clearTimeout(timeout);
       　　　　 if(curTime - startTime >= atleast) {
        　　    fn();
           　　 startTime = curTime;
        　　　　}else {
           　　　　 timeout = setTimeout(fn, delay);
        　　　　}
        }
    }
    function lazyload() {
        var images = document.getElementsByTagName('img');
        var len    = images.length;
        var n      = 0;      //存储图片加载到的位置，避免每次都从第一张图片开始遍历        
        return function() {
        　　　　var seeHeight = document.documentElement.clientHeight;
       　　　　 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
     　　　　   for(var i = n; i < len; i++) {
           　　　　 if(images[i].offsetTop < seeHeight + scrollTop) {
               　　　　 if(images[i].getAttribute('src') === 'images/loading.gif') {
               　　　　　　  images[i].src = images[i].getAttribute('data-src');
               　　　　 }
           　　　　　　 n = n + 1;
            　　　　}
        　　　　}
        }
    }
    var loadImages = lazyload();
    loadImages();          //初始化首页的页面图片
    window.addEventListener('scroll', throttle(loadImages, 500, 1000), false);
　　//函数节流（throttle）与函数去抖（debounce）处理,
//500ms 的延迟，和 1000ms 的间隔，当超过 1000ms 未触发该函数，则立即执行该函数，不然则延迟 500ms 执行该函数
    </script>
</body>
</html>
```


#### 29、谈谈你对this的理解

隐式绑定的场景讨论:
+ this 永远指向函数运行时所在的对象，而不是函数创建时所在的对象。
+ 匿名函数和不处于任何对象中的函数，this指向window.
+ 普通函数调用，函数被谁调用，this就指向谁。

显式绑定的场景讨论:

+ call,appply,with 指的this 是谁就是谁。

#### 30、js创建对象的几种方式
`javascript 创建对象简单的说,⽆⾮就是使⽤内置对象或各种⾃定义对象， 当然还可以⽤ JSON ；但写法有很多种，也能混合使⽤`

+ 对象字⾯量的⽅式
```javascript
person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
​```javascript
+ ⽤ function 来模拟⽆参的构造函数
​```javascript
function Person(){}
var person=new Person();//定义⼀个function，如果使⽤new"实例化",该function可
 person.name="Mark";
 person.age="25";
 person.work=function(){
 alert(person.name+" hello..."); }
person.work();
```
+ ⽤ function 来模拟参构造函数来实现（⽤ this 关键字定义构造的上下⽂属性）
```javascript
function Pet(name,age,hobby){
 this.name=name;//this作⽤域：当前对象
 this.age=age;
 this.hobby=hobby;
 this.eat=function(){
 alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
 } }
var maidou =new Pet("⻨兜",25,"coding");//实例化、创建对象
maidou.eat();//调⽤eat⽅法
```
+ ⽤⼯⼚⽅式来创建（内置对象）
```javascript
var wcDog =new Object();
 wcDog.name="旺财";
 wcDog.age=3;
 wcDog.work=function(){
 alert("我是"+wcDog.name+",汪汪汪......");
 }
 wcDog.work();
```
+ ⽤原型⽅式来创建
```javascript
function Dog(){}
Dog.prototype.name="旺财";
Dog.prototype.eat=function(){
alert(this.name+"是个吃货"); }
var wangcai =new Dog();
wangcai.eat();
```
+ ⽤混合⽅式来创建
```
function Car(name,price){
this.name=name;
this.price=price; }
Car.prototype.sell=function(){
alert("我是"+this.name+"，我现在卖"+this.price+"万元"); }
var camry =new Car("凯美瑞",27);
camry.sell();
```

#### 31、eval是做什么的
+ 它的功能是把对应的字符串解析成 JS 代码并运⾏
+ 应该避免使⽤ eval ，不安全，⾮常耗性能（ 2 次，⼀次解析成 js 语句，⼀次执⾏）
+ 由 JSON 字符串转换为JSON对象的时候可以⽤ eval，var obj =eval('('+ str +')')

#### 32、谈谈你对ES6的理解
+ 新增模板字符串（为 JavaScript 提供了简单的字符串插值功能）
+ 箭头函数
+ for-of （⽤来遍历数据—例如数组中的值。）
+ arguments 对象可被不定参数和默认参数完美代替。
+ ES6 将p romise 对象纳⼊规范，提供了原⽣的 Promise 对象。
+ 增加了 let 和 const 命令，⽤来声明变量。
+ 增加了块级作⽤域。
+ let 命令实际上就增加了块级作⽤域。
+ 还有就是引⼊ module 模块的概念

#### 33、异步编程的实现⽅式
+ 回调函数
	+ 优点：简单、容易理解
	+ 缺点：不利于维护，代码耦合⾼
+ 事件监听(采⽤时间驱动模式，取决于某个事件是否发⽣)：
	+ 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
	+ 缺点：事件驱动型，流程不够清晰
+ 发布/订阅(观察者模式)
	+ 类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者
+ Promise对象
	+ 优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；
	+ 缺点：编写和理解，相对⽐较难
+ Generator函数
	+ 优点：函数体内外的数据交换、错误处理机制
	+ 缺点：流程管理不⽅便
+ async函数
	+ 优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。
	+ 缺点：错误处理机制

#### 34、模块化
**模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。**
+ 分类:
	+ es6: import / export
	+ commonjs: require / module.exports / exports
	+ amd: require / defined
+ require与import的区别
	+ require支持 动态导入，import不支持，正在提案 (babel 下可支持)
	+ require是 同步 导入，import属于 异步 导入
	+ require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化

#### 35、 babel编译原理
+ babylon 将 ES6/ES7 代码解析成 AST
+ babel-traverse 对 AST 进行遍历转译，得到新的 AST
+ 新 AST 通过 babel-generator 转换成 ES5

#### 36、什么是AST？
**抽象语法树 (Abstract Syntax Tree)，是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:**
```javascript
function square(n){
	return n * n
}
```
通过解析转化成的AST如下图:

![img](https://user-gold-cdn.xitu.io/2019/2/14/168e9d95910dd187?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 37、JSON 的了解
+ JSON(JavaScript Object Notation) 是⼀种轻量级的数据交换格式
+ 它是基于 JavaScript 的⼀个⼦集。数据格式简单, 易于读写, 占⽤带宽⼩
+ JSON 字符串转换为JSON对象:
```javascript
var obj =eval('('+ str +')');
var obj = str.parseJSON();
var obj = JSON.parse(str);
```
+ JSON 对象转换为JSON字符串：
```javascript
var last=obj.toJSONString();
var last=JSON.stringify(obj);
```

#### 38、为什么typeof null是Object

**因为在JavaScript中，不同的对象都是使用二进制存储的，如果二进制前三位都是0的话，系统会判断为是Object类型，而null的二进制全是0，自然也就判断为Object**

#### 39、['1','2','3'].map(parseInt) 输出什么，为什么?
输出：**[1, NaN, NaN]**
+ 首先让我们回顾一下，map 函数的第一个参数 callback：
```js
var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
```
这个 callback 一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。

而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。

parseInt(string, radix)

接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

![image-20210307173901902](C:\Users\LI\AppData\Roaming\Typora\typora-user-images\image-20210307173901902.png)

+ 了解这两个函数后，我们可以模拟一下运行情况
	+ parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1
	+ parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN
	+ parseInt('3', 2) //基数为 2（2进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN

+ map 函数返回的是一个数组，所以最后结果为[1, NaN, NaN]

#### 40、for in && for of的区别
for in
> for ... in 循环返回的值都是数据结构的 键值名。
遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。
for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。
特别情况下, for ... in 循环会以任意的顺序遍历键名

**总结: for in 循环特别适合遍历对象**

for of
> for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名
一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。
for of 不同与 forEach, 它可以与 break、continue和return 配合使用,
也就是说 for of 循环可以随时退出循环。

#### 41、ES6的map，set有什么区别
如果要用一句话来描述，我们可以说
Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构
什么是集合？什么又是字典？

+ 集合是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合

+ 字典是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同

**区别：**
+ 共同点：集合、字典都可以存储不重复的值

+ 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储

#### 42、判断某个DOM节点是否存在于指定DOM节点中
> 通过操作DOM中的节点node

```js
<div id="great">
    <div id="grand">
        <div id="parent">
            <div id="child"></div>
        </div>
    </div>
</div>
<script type="text/javascript">
    var great = document.getElementById('great');    //曾祖父节点
    var grand = document.getElementById('grand');    //祖父节点
    var parent = document.getElementById('parent');  //父节点
    var child = document.getElementById('child');    //子节点
 
    function isChildOf(parent, child) {
        var parentNode;
        if(child && parent) {
            parentNode = child.parentNode;
            while(parentNode) {
                if(parent === parentNode) {
                    return true;
                }
                parentNode = parentNode.parentNode;
            }
        }
        return false;
    }
    console.log(isChildOf(great, grand));
    console.log(isChildOf(great, parent));
    console.log(isChildOf(great, child));
    console.log(isChildOf(grand, parent));
    console.log(isChildOf(grand, child));
    console.log(isChildOf(parent, child));
</script>
```




# 四、Ajax

#### 1、如何解决跨域

**1. JSONP跨域【目前已基本不用了】**
JSONP(JSON with Padding: 填充式JSON)，应用于JSON的一种新方法。
JSON、JSONP的区别：
+ JSON返回的是一串数据，JSONP返回的是脚本代码(包含一个函数调用)
+ JSONP只支持get请求、不支持post请求（类似往页面添加一个script标签，通过src属性去触发对指定地址的请求，故只能是Get请求）

JSONP应用的技巧：
`在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的。`

**2. CORS跨域**
后端修改请求头
header(‘Access-Control-Allow-Origin:*’);允许访问的网址
header(‘Access-Control-Allow-Method:POST,GET’);允许访问的方式

**3. nginx反向代理**
www.baidu.com/index.html需要调用www.sina.com/server.php,可以写一个接口www.baidu.com/server.php,由这个接口在后端去调用www.sina.com/server.php并拿到返回值，然后再返回给index.html

**4. document.domain**
跨域分为俩种，一种xhr不能访问不同源的文档，另一种是不同window之间不能进行交互操作；
document.domain主要解决第二种情况，且只能适用于主域相同子域不同的情况；
document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如： a.b.example.com 中某个文档的document.domain可以设成a.b.example.com、b.example.com、example.com中的任意一个，但是不可以设成c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com，因为主域已经不相同了。
**兼容性：**
所有浏览器都支持；
**优点：**
可以实现不同window之间的相互访问和操作；
**缺点：**
只适用于window之间的通信，不能用于xhr；
只能在主域相同且子域不同的情况下使用；
**使用方式：**
不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.example.com/a.html，在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的。
示例代码：
```javascript
<script>
function test(){
	var iframe = document.getElementById('￼ifame');
	var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的
	var doc = win.document;//这里获取不到iframe里的document对象
	var name = win.name;//这里同样获取不到window对象的name属性
}
</script>
<iframe id = "iframe" src="http://example.com/b.html" onload = "test()"></iframe>
```
这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。
1.在页面 http://www.example.com/a.html 中设置document.domain:
```javascript
<iframe id = "iframe" src="http://example.com/b.html" onload = "test()"></iframe>
<script type="text/javascript">
    document.domain = 'example.com';//设置成主域
    function test(){
        alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象
    }
</script>
```
2.在页面 http://example.com/b.html中也设置document.domain:
```javascript
<script type="text/javascript">
    document.domain = 'example.com';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同
</script>
```

**5. window.name**
**关键点：**
window.name在页面的生命周期里共享一个window.name;
**兼容性：**
所有浏览器都支持；
**优点:**
最简单的利用了浏览器的特性来做到不同域之间的数据传递；
不需要前端和后端的特殊配置；
**缺点：**
大小限制：window.name最大size是2M左右，不同浏览器中会有不同约定；
**安全性：**
当前页面所有window都可以修改，很不安全；
**数据类型：**
传递数据只能限于字符串，如果是对象或者其他会自动被转化为字符串。
**使用方式：**
修改window.name的值即可；

**6. postMessage**
**关键点：**
postMessage是h5引入的一个新概念，现在也在进一步的推广和发展中，他进行了一系列的封装，我们可以通过window.postMessage的方式进行使用，并可以监听其发送的消息；
**兼容性：**
移动端可以放心用，但是pc端需要做降级处理
**优点：**
不需要后端介入就可以做到跨域，一个函数外加俩个参数(请求url，发送数据)就可以搞定；
移动端兼容性好；
**缺点：**
无法做到一对一的传递方式：监听中需要做很多消息的识别，由于postMessage发出的消息对于同一个页面的不同功能相当于一个广播的过程，该页面的所有onmessage都会收到，所以需要做消息的判断；
**安全性问题：**
三方可以通过截获，注入html或者脚本的形式监听到消息，从而能够做到篡改的效果，所以在postMessage和onMessage中一定要做好这方面的限制；
发送的数据会通过结构化克隆算法进行序列化，所以只有满足该算法要求的参数才能够被解析，否则会报错，如function就不能当作参数进行传递；
**使用方式：**
通信的函数，sendMessage负责发送消息，bindEvent负责消息的监听并处理，可以通过代码来做一个大致了解；
**示例代码：**
```javascript
Storage.prototype.sendMessage_=function(type,params,fn){
   if(this.topWindow){
       this.handleCookie_(type,params,fn);
       return;
   }
   var eventId = this.addToQueue_(fn,type);
   var storageIframe = document.getElementById('mip-storage-iframe');
   var element = document.createElement("a");
   element.href = this.origin;
   var origin = element.href.slice(0,element.href.indexOf(element.pathname)+1);
   storageIframe.contentWindow.postMessage({
       type:type,
       params:params,
       eventId:eventId
   },origin);
}
Storage.prototype.bindEvent_=function(){
   window.onmessage = function(res){
       //判断消息来源
       if(window == res.source.window.parent &&
           res.data.type === this.messageType.RES &&
           window.location.href.match(res.origin.host).length >0){
           var fn = this.eventQueue[res.data.eventId];
           fn && fn();
           delete this.eventQueue[res.data.eventId];
           var isEmpty = true;
           for(var t in this.eventQueue){
               isEmpty = false;
           }
           if(isEmpty){
               this.id = 0;
           }
       }
   }.bind(this);
}
```

#### 2、同源策略
**同源策略**
同源策略由Netscape提出的一个著名的安全策略。
现在所有可以支持JavaScript的浏览器都会使用这一策略。

**同源**
同源即 同协议，端口，域名

**同源策略的限制**
	1、不能获取不同源的cookie，LocalStorage 和 indexDB
	2、不能获取非同源的DOM
	3、不能发送非同源的ajax请求。（准确说应该是可以向非同源的服务器发起请求，但是返回的数据会被浏览器拦截）

**同源策略由浏览器执行**
所有的限制都是因为浏览器的作用，这是因为浏览器为保护用户隐私而才去的措施。

**为什么要有同源策略**
采用同源策略主要是因为安全。若非同源下的cookie等隐私数据可以被随意获取，非同源下的DOM可以的随意操作，ajax可以任意请求的话，用户的各种隐私势必泄露。

**再来细说一下同源策略的限制**
+ 不能获取不同源的cookie，LocalStorage 和 indexDB
+ 不能让获取非同源的DOM
+ 不能发送非同源的ajax请求。

#### 3、AJAX都有哪些优点和缺点
**优点：**
+ 1.无刷新更新数据
　　Ajax最大的优点就是能在不刷新整个页面的情况下维持与服务器通信
+ 2.异步与服务器通信
　　使用异步的方式与服务器通信，不打断用户的操作
+ 3.前端与后端负载均衡
　　将一些后端的工作移到前端，减少服务器与带宽的负担
+ 4.基于规范被广泛支持
　　不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。
+ 5.界面与应用分离
　　Ajax使得界面与应用分离，也就是数据与呈现分离

　**缺点：**
　+ 1.Ajax干掉了Back与History功能，即对浏览器机制的破坏
　　在动态更新页面的情况下，用户无法回到前一页的页面状态，因为浏览器仅能记忆历史纪录中的静态页面
　+ 2.安全问题
　　AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。
　+ 3.对搜索引擎支持较弱
　+ 4.破坏程序的异常处理机制
　+ 5.违背URL与资源定位的初衷
　+ 6.不能很好地支持移动设备
　+ 7.客户端肥大，太多客户段代码造成开发上的成本

#### 4、解释 jsonp 的原理，以及为什么不是真正的 ajax?
1. jsonp的原理:就是利用浏览器可以动态地插入一段js并执行的特点完成的。
2. 为什么不是真正的 ajax?
+ ajax的核心是 ： 通过XmlHttpRequest获取非本页内容，
+ jsonp的核心 ： 动态添加<script>标签来调用服务器提供的js脚本。

3.ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；

4.实质不同
  		ajax的核心是通过xmlHttpRequest获取非本页内容
 		 jsonp的核心是动态添加script标签调用服务器提供的js脚本

5.ajax通过服务端代理一样跨域
  		jsonp也不并不排斥同域的数据的获取

6 .jsonp是一种方式或者说非强制性的协议
  		ajax也不一定非要用json格式来传递数据

7.jsonp只支持get请求，ajax支持get和post请求

#### 5、什么是Promise？
`Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态： pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。`

**例如：**
```js
// 当参数a大于10且参数fn2是一个方法时 执行fn2
function fn1(a, fn2) {
    if (a > 10 && typeof fn2 == 'function') {
        fn2()
    }
}
fn1(11, function() {
    console.log('this is a callback')
})
```
一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。
这时候我们的promise就应运而生、粉墨登场了

**promise是用来解决两个问题的：**
+ 回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象
+ promise可以支持多个并发的请求，获取并发请求中的数据
+ 这个promise可以解决异步的问题，本身不能说promise是异步的

# 五、VUE

#### 1、vue生命周期
**一、什么是 vue 生命周期**
Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

![img](https://img-blog.csdnimg.cn/20200928091034818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5ndmFsdWU=,size_16,color_FFFFFF,t_70)

**二、生命周期函数**
Vue 的生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。

1、beforeCreate（创建前）

表示实例完全被创建出来之前，vue 实例的挂载元素$el和数据对象 data 都为 undefined，还未初始化。

2、created（创建后）

数据对象 data 已存在，可以调用 methods 中的方法，操作 data 中的数据，但 dom 未生成，$el 未存在 。

3、beforeMount（挂载前）

vue 实例的 $el 和 data 都已初始化，挂载之前为虚拟的 dom节点，模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中。data.message 未替换。

4、mounted（挂载后）

vue 实例挂载完成，data.message 成功渲染。内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了。实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，DOM 渲染在 mounted 中就已经完成了。

5、beforeUpdate（更新前）

当 data 变化时，会触发beforeUpdate方法 。data 数据尚未和最新的数据保持同步。

6、updated（更新后）

当 data 变化时，会触发 updated 方法。页面和 data 数据已经保持同步了。

7、beforeDestory（销毁前）

组件销毁之前调用 ，在这一步，实例仍然完全可用。

8、destoryed（销毁后）

组件销毁之后调用，对 data 的改变不会再触发周期函数，vue 实例已解除事件监听和 dom绑定，但 dom 结构依然存在。

**activated,deactivated**

> 注意一点：activated,deactivated这两个生命周期函数一定是要在使用了keep-alive组件后才会有的，否则则不存在当引入keep-alive的时候，页面第一次进入，钩子的触发顺序created-> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。

#### 2、v-show和v-if的区别？
**1.共同点：**
+ 都能控制元素的显示和隐藏。

**2.不同点：**
+ 实现本质⽅法不同，v-show本质就是通过控制css中的display设置为none，控制隐藏，只会编译⼀次；v-if是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。⽽且v-if不停的销毁和创建⽐较消耗性能。

**3.总结：**
+ 如果要频繁切换某节点，使⽤v-show(切换开销⽐较⼩，初始开销较⼤)。如果不需要频繁切换某节点使⽤v-if（初始渲染开销较⼩，切换开销⽐较⼤）。

#### 3、vue-router有哪些导航钩子
+ beforeEach
	+ 参数有
		+ to(Route路由对象)
		+ from(Route路由对象)
		+ next(function函数) 一定要调用才能进行下一步
+ afterEach
+ beforeRouterLeave

#### 4、vue双向绑定的原理
**数据劫持：**vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter,在数据变动时发布消息给订阅者，触发相应的监听回调

**阐述一下你所理解的MVVM响应式原理**
vue是采用数据劫持配合发布者-订阅者的模式的方式，通过Object.defineProperty()来劫持各个属性的getter和setter，在数据变动时，发布消息给依赖收集器（dep中的subs），去通知（notify）观察者，做出对应的回调函数，去更新视图

MVVM作为绑定的入口，整合Observer,Compile和Watcher三者，通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer，Compile之间的通信桥路，达到数据变化=>视图更新；视图交互变化=>数据model变更的双向绑定效果。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210301110203552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NTc3OQ==,size_16,color_FFFFFF,t_70)

> 1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，
以及绑定相应的更新函数
3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，
执行指令绑定的相应回调函数，从而更新视图
4、mvvm 入口函数，整合以上三者

**简略版双向数据绑定原理:**

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<div id="app"></div>
<input type="text" id="phone">
<script>
  let app = document.getElementById('app');
  let phone = document.getElementById('phone');
  // 双向数据绑定的原理：在 vue 创建实例的时候，会遍历 data 中的属性，通过一个
  // Object.defineProperty() 方法把 data 中的属性都改成 getter 和 setter；当获取这个值时，
  // 会触发 get 方法，当修改属性值的时候会触发 set 方法；vue 在此之前会收集所有依赖 data 属性
  // 的元素，当依赖的这个值发生改变时，会触发 set 方法，然后 vue 会更新所有依赖这个数据的元素；
  let obj = {
    _phone: '15910608684'
  };
  app.innerHTML = obj._phone;
  phone.value = obj._phone;
  // Object.defineProperty() 定义对象属性的特性的
  Object.defineProperty(obj, 'phone', {
    get() {
      // 获取 obj.name 会执行 get 方法
      return this._phone;
    },
    set(val) {
      // 修改 obj.name 时会执行 set 方法
      this._phone = val;
      app.innerHTML = val;
    }
  });
  phone.oninput = function () {
    obj.phone = this.value;
  }
  // console.log(obj.name);  取值时会执行 get 方法
  // obj.name = 100;  修改对象的属性值的时候会触发 set 方法
</script>
</body>
</html>
```


#### 5、vue中父子组件的生命周期
+ 父子组件的生命周期是一个嵌套的过程
+ 渲染的过程
	+ 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
+ 子组件更新过程
	+ 父beforeUpdate->子beforeUpdate->子updated->父updated
+ 父组件更新过程
	+ 父beforeUpdate->父updated
+ 销毁过程
	+ 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

#### 6、Vue中的nextTick
+ nextTick
	+ 解释
		+ nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
	+ 应用
		+ 想要在Vue生命周期函数中的created()操作DOM可以使用Vue.nextTick()回调函数
		+ 在数据改变后要执行的操作，而这个操作需要等数据改变后而改变DOM结构的时候才进行操作，需要用到nextTick

#### 7、computed和watch的区别
+ computed
	+ 计算属性，依赖其他属性，当其他属性改变的时候下一次获取computed值时也会改变，computed的值会有缓存
+ watch
	+ 类似于数据改变后的回调
	+ 如果想深度监听的话，后面加一个deep:true
	+ 如果想监听完立马运行的话，后面加一个immediate:true

#### 8、Vue优化方式
+ v-if 和v-show
+ 使用Object.freeze()方式冻结data中的属性，从而阻止数据劫持
+ 组件销毁的时候会断开所有与实例联系，但是除了addEventListener，所以当一个组件销毁的时候需要手动去removeEventListener
+ 图片懒加载
+ 路由懒加载
+ 为减少重新渲染和创建dom节点的时间，采用虚拟dom

#### 9、Vue-router的模式
+ hash模式
	+ 利用onhashchange事件实现前端路由，利用url中的hash来模拟一个hash，以保证url改变时，页面不会重新加载。
+ history模式
	+ 利用pushstate和replacestate来将url替换但不刷新，但是有一个致命点就是，一旦刷新的话，就会可能404，因为没有当前的真正路径，要想解决这一问题需要后端配合，将不存在的路径重定向到入口文件。

#### 10、MVC与MVVM有什么区别
**MVVM：**

> MVVM：M model 层 是数据层
>
> ​    V view 层 视图层
>
> ​    VM view-model 视图模型
>
> MVVM 中是 VM 吧视图和数据层联系起来，把数据映射成视图，当数据变更时会自动更新视图
>
> 双向数据绑定：把数据映射成视图，数据发生变化，更新视图；同时，如果视图发生变更，更新数据

+ MVC
	+ Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。
	+ View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
	+ Controller（控制器）是应用程序中处理用户交互的部分。
		+ 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

#### 11、虚拟DOM的优缺点
+ 缺点
	+ 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢
+ 优点
	+ 减少了dom操作，减少了回流与重绘
	+ 保证性能的下限，虽说性能不是最佳，但是它具备局部更新的能力，所以大部分时候还是比正常的DOM性能高很多的

#### 12、Vue的Key的作用
+ key主要用在虚拟Dom算法中，每个虚拟节点VNode有一个唯一标识Key，通过对比新旧节点的key来判断节点是否改变，用key就可以大大提高渲染效率，这个key类似于缓存中的etag。

#### 13、Vue组件之间的通信方式
+ 子组件设置props + 父组件设置v-bind:/:
	
	+ 父传子
+ 子组件的$emit + 父组件设置v-on/@
	
	+ 子传父
+ 任意组件通信，新建一个空的全局Vue对象，利用e m i t 发 送 ， emit发送，emit发送，on接收
	+ 传说中的$bus
	+ 任意组件
```javascript
Vue.prototype.Event=new Vue();
Event.$emit(事件名,数据);
Event.$on(事件名,data => {});
```
+ Vuex
	+ state
		+ 存储数据的
		+ 获取数据最好推荐使用getters
		+ 硬要使用的话可以用MapState， 先引用，放在compute中...mapState(['方法名','方法名'])
	+ getters
		+ 获取数据的
		+ this.$store.getters.xxx
		+ 也可使用mapGetters 先引用，放在compute中，...mapGetters(['方法名','方法名'])
	+ mutations
		+ 同步操作数据的
		+ this.$store.commit(“方法名”,数据)
		+ 也可使用mapMutations ，使用方法和以上一样
	+ actions
		+ 异步操作数据的
		+ this.$store.dispatch(“方法名”,数据)
		+ 也可使用mapActions ，使用方法和以上一样
	+ modules
		+ 板块，里面可以放多个vuex
+ 父组件通过v-bind:/:传值，子组件通过this.$attrs获取
	+ 父传子
	+ 当子组件没有设置props的时候可以使用
	+ this.$attrs获取到的是一个对象（所有父组件传过来的集合）
+ 祖先组件使用provide提供数据，子孙组件通过inject注入数据
+ parent/children
+ refs—$ref
+ 还有一个，这个网上没有，我自己认为的，我觉得挺对的，slot-scope，本身父组件使用slot插槽是无法获取子组件的数据的，但是使用了slot-scope就可以获取到子组件的数据（拥有了子组件的作用域）

#### 14、$route和$router的区别
+ this.$route：当前激活的路由的信息对象。每个对象都是局部的，可以获取当前路由的 path, name, params, query 等属性。
+ this.$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（比如 history 对象），任何页面也都可以调用其 push(), replace(), go() 等方法。

#### 15、vue中为什么data要是一个函数
1.基本数据类型是放在栈里面的，它是按值访问，在栈内存中发生复制行为时系统会为新的变量提供新值，所以两个变量互不影响
2.引用数据类型是放在堆内存中的，它是按引用访问的，在栈内存中有一个地址是指向堆内存中的引用数据类型的，所以我们拷贝引用数据类型其实就是拷贝了栈内存中的地址，因为地址一样，他们都是指向同一个引用数据类型，所以两个变量会相互影响，这时就必须使用深拷贝了

+ 如果能理解深浅拷贝就可以理解 data 为什么要用函数了
+ 在创建或注册模板的时候传入一个 data 属性作为用来绑定的数据。但是在组件中，data必须是一个函数，因为每一个 vue 组件都是一个 vue 实例，通过 new Vue() 实例化，引用同一个对象，如果 data 直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变，而 data 是函数的话，每个 vue 组件的 data 都因为函数有了自己的作用域，互不干扰。

#### 16、对keep-alive的了解
**keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。**
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。
```vue
<keep-alive include='include_components' exclude='exclude_components'>
  <component>
    <!-- 该组件是否缓存取决于include和exclude属性 -->
  </component>
</keep-alive>
```
参数解释:
+ include - 字符串或正则表达式，只有名称匹配的组件会被缓存
+ exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
+ include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 

```vue
<!-- 逗号分隔字符串，只有组件a与b被缓存。 -->
<keep-alive include="a,b">
  <component></component>
</keep-alive>
 
<!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) -->
<keep-alive :include="/a|b/">
  <component></component>
</keep-alive>
 
<!-- Array (需要使用 v-bind，被包含的都会被缓存) -->
<keep-alive :include="['a', 'b']">
  <component></component>
</keep-alive>
```

#### 17、前端路由实现原理
**1.hash路由实现 **
`hash路由改变不会触发浏览器刷新, 会触发相应的hashchange事件`

**2. history路由实现**
`History 路由是基于 HTML5 规范，在 HTML5 规范中提供了 history.pushState || history.replaceState 来进行路由控制。`
`使用history.pushState({}, null, ‘/home’)时候, 页面不会刷新，pushState会有页面记录，replaceState不会有`

pushState方法说明:
+ state：存储 JSON 字符串，可以用在 popstate 事件中
+ title：现在大多浏览器忽略这个参数，直接用 null 代替
+ url：任意有效的 URL，用于更新浏览器的地址栏

#### 18、spa单页面的理解以及优缺点
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点：**
+ 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
+ 基于上面一点，SPA 相对对服务器压力小；
+ 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**
+ 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
+ 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
+ SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

#### 19、vue的extend、extends、mixin
**Vue.extend( options )**
+ 参数：
	
	+ {Object} options
+ 用法：
	使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。
	data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数
	```html
	<div id="mount-point"></div>
	```
	```js
	// 创建构造器
	var Profile = Vue.extend({
	  template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
	  data: function () {
	    return {
	      firstName: 'Walter',
	      lastName: 'White',
	      alias: 'Heisenberg'
	    }
	  }
	})
	// 创建 Profile 实例，并挂载到一个元素上。
	new Profile().$mount('#mount-point')
	```
	结果如下：
	```html
	<p>Walter White aka Heisenberg</p>
	```

**extends继承**
		常用来扩展单文件组件

**注意事项：**
+ 1、extends只可以用来扩展一个。
+ 2、合并规则和mixin的一样。

**mixin混入**.
		`混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。`

```js
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // => "hello from mixin!"
```

#### 20、vue-template怎么理解
**1、template标签在vue实例绑定的元素内部**
`它是可以显示template标签中的内容，但是查看后台的dom结构不存在template标签。如果template标签不放在vue实例绑定的元素内部默认里面的内容不能显示在页面上，但是查看后台dom结构存在template标签。`

**注意：**vue实例绑定的元素内部的template标签不支持v-show指令，即v-show="false"对template标签来说不起作用。但是此时的template标签支持v-if、v-else-if、v-else、v-for这些指令。

**2、vue实例中的template属性**

`将实例中template属性值进行编译，并将编译后的dom替换掉vue实例绑定的元素，如果该vue实例绑定的元素中存在内容，这些内容会直接被覆盖。`

**特点：**
+ 1）如果vue实例中有template属性，会将该属性值进行编译，将编译后的虚拟dom直接替换掉vue实例绑定的元素（即el绑定的那个元素）；
+ 2）template属性中的dom结构只能有一个根元素，如果有多个根元素需要使用v-if、v-else、v-else-if设置成只显示其中一个根元素；
+ 3）在该属性对应的属性值中可以使用vue实例data、methods中定义的数据。

#### 21、Vue的DOM更新是同步还是异步？

> Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。

**虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 ``Vue.nextTick(callback)``。这样回调函数将在 DOM 更新完成后被调用。例如：**

```html
<div id="example">{{message}}</div>
```

```js
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'new message' // 更改数据
vm.$el.textContent === 'new message' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'new message' // true
})
```

#### 22、如何在一个自定义组件上使用v-model?

**方法1：利用父子组件绑定事件传值即可**

**方法2：直接使用v-model的定制prop 和 event来实现**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191212184108616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09yYWxpbmdl,size_16,color_FFFFFF,t_70)

#### 23、v-html在使用的时候需要注意什么问题？
**vue的v-html指令使用注意事项：**
> 1、V-html更新的是元素的 innerHTML 。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。但是有的时候我们需要渲染的html片段中有插值表达式，或者按照Vue模板语法给dom元素绑定了事件；

> 2、使用v-html需要注意的第二个问题是：在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局

可以使用/deep/解决


#### 24、vue的好处
+ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变
+ 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑
+ 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写

#### 25、Vue2.0的双向绑定，有什么缺点，怎么改进(vue3.0的proxy)
> defineProperty API 的局限性最大原因是它只能针对单例属性做监听。

+ Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历  递归，为每个属性设置了 getter、setter。
+ 这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在Vue中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到setter监听的，这是defineProperty的局限性。

> Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。

+ Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

> 响应式是惰性的

+ 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。
+ 在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。
+ 基础用法：

```js
    let datas = {
        num: 0
    }
    let proxy = new Proxy(datas, {
        get(target, property) {
            return target[property]
        },
        set(target, property, value) {
            target[property] += value
        }
    })
```

#### 26、vue2.x中如何监测数组变化
> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

#### 27、接口请求一般放在哪个生命周期中？
**接口请求一般放在mounted中，但需要注意的是服务器渲染的时候不支持mounted，需要放到created中**

#### 28、说一下v-model的原理
> v-model本质就是一个语法糖，可以看成是value+input方法的语法糖。可以通过model属性的prop和event属性来进行自定义。

**原生的v-model，会根据标签的不同生成不同的事件和属性**

#### 29、SSR了解吗？
> SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

**SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求**

#### 30、diff算法
+ diff算法是指对新旧虚拟节点进行对比，并返回一个patch对象，用来存储两个节点不同的地方，最后利用patch记录的消息局部更新DOM


#### 31、Vue2.x和Vue3.x渲染器的diff算法分别说一下
+ 同级比较，再比较子节点
+ 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
+ 比较都有子节点的情况(核心diff)
+ 递归比较子节点
+ 正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。
+ Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅
+ 在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升


#### 32、虚拟 DOM 实现原理？
虚拟 DOM 的实现原理主要包括以下 3 部分：

+ 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
+ diff 算法 — 比较两棵虚拟 DOM 树的差异；
+ pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。





# 六、场景题(编程题)

#### 1、Array.from 达到 .map 的效果
> 咱们都知道 .map() 方法，.from() 方法也可以用来获得类似的效果且代码也很简洁。

![image-20210307194733613](C:\Users\LI\AppData\Roaming\Typora\typora-user-images\image-20210307194733613.png)

#### 2、将数组转换为对象
> 有时候，出于某种目的，需要将数组转化成对象，一个简单快速的方法是就使用展开运算符号(...):

![image-20210307194855262](C:\Users\LI\AppData\Roaming\Typora\typora-user-images\image-20210307194855262.png)

#### 3、求两个数组的交集
> 求两个数组的交集在面试中也是有一定难度的正点，为了找到两个数组的交集，首先使用上面的方法确保所检查数组中的值不重复，接着使用.filter 方法和.includes方法。如下所示：

![image-20210307195046254](C:\Users\LI\AppData\Roaming\Typora\typora-user-images\image-20210307195046254.png)

#### 4、删除js数组中的偶数
> 使用数组去重外加判断即可

#### 5、repeatFunc("hellworld");
```js
function repeat(func,times,wait) {
  let curtime=0;
  return function(str) {
    function run() {
      func(str);
      curtime++;
      if(curtime<times) {
        setTimeout(run,wait);
      }
    }
    run();
  }
}
```

#### 6、Javascript实现字符串反转
```js
//方法1
function strReverse(str) {
	 return str.split("").reverse().join("") 
}

//方法2
function strReverse(str) {
		var newstr="";
           for(var i=0;i<str.length;i++){
               newstr=str.charAt(i)+newstr;
           }
           return newstr
}
```

#### 7、数组扁平化
```js
const flat = (arr) => {
  for (let i = 0; i < arr.length; i++) {
      const temp = arr[i];
      if(Array.isArray(temp)) {
          arr.splice(i, 1, ...flat(temp))
      }
  }
  return arr
}
let temp =[1, [2, [3, [4]]]]
console.log(flat(temp))
```

#### 8、创建 10 个<a>标签，点击的时候弹出来对应的序号
```javascript
var i
for (i = 0; i < 10; i++) {
    (function (i) {
        var a = document.createElement('a')
        a.innerHTML = i + '<br>'
        a.addEventListener('click', function (e) {
            e.preventDefault()
            alert(i)
        })
        document.body.appendChild(a)
    })(i)
}
```

#### 9、重写数组中的map方法

![image-20210309110741559](C:\Users\LI\AppData\Roaming\Typora\typora-user-images\image-20210309110741559.png)
```js
Array.prototype.myMap=function(callback){
	//如果没有传入回调函数，则报错
	if(!callback) throw new TypeError('undefined is not a function');
	if (typeof callback !== 'function') {//传入的不是函数也报错
      throw new TypeError(callback + " is not a function");
    }
    var res=[];//定义返回数组
	for(var i=0,len=this.length;i<len;i++){
		res.push(callback(this[i],i,this));//将函数的返回值添加到返回数组
	}
	return res;//返回结果
}
```

#### 10、重写一个new方法
```js

function _new(constructer, ...arg) {
   // 创建一个空的对象
   let resultObj = {};
   // 链接该对象到原型,这样新对象就能访问到原型上面的方法
   resultObj.__proto__ = constructer.prototype;
   // 然后实现步骤3，将新创建的对象作为this的上下文
   let result = constructer.call(resultObj, ...arg);
   // 实现步骤4：如果该函数没有返回对象（即result不是一个对象），则返回this（即resultObj)
   return typeOf result === 'object' ? result : resultobj
   
   // 接下来就可以看看new的实现效果了
}
```

#### 11、函数柯里化
```js
function add() {
    var _args = [...arguments];
    var _adder = function() {
        _args.push(...arguments);
        return _adder;
    }
    _adder.toString = function() {
        return _args.reduce((prev, next) => {
            return prev + next;
        });
    }
    return _adder;
}
```

